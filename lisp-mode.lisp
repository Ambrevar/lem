(in-package :lem)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (dolist (elt '((block . 1)
                 (case . 1)
                 (ccase . case)
                 (ecase . case)
                 (typecase . case)
                 (etypecase . case)
                 (ctypecase . case)
                 (catch . 1)
                 ;(cond . 0)
                 (defclass . defun)
                 (define-condition . defun)
                 (define-modify-macro . 1)
                 (defsetf . defun)
                 (defun . 2)
                 (define-setf-method . defun)
                 (define-setf-expander . defun)
                 (defmacro . defun)
                 (deftype . defun)
                 (defmethod . defun)
                 (defpackage . 1)
                 (defstruct . 1)
                 (destructuring-bind . 2)
                 (do . 2)
                 (do* . do)
                 (dolist . 1)
                 (dotimes . dolist)
                 (eval-when . 1)
                 (flet . 1)
                 (labels . flet)
                 (macrolet . flet)
                 (generic-flet . flet)
                 (generic-labels . flet)
                 (handler-case . 1)
                 (restart-case . handler-case)
                 (if . 1)
                 (lambda . 1)
                 (let . 1)
                 (let* . let)
                 (handler-bind . let)
                 (restart-bind . let)
                 (locally . 0)
                 (multiple-value-bind . 2)
                 (multiple-value-call . 1)
                 (multiple-value-prog1 . 1)
                 (prog . 1)
                 (prog* . prog)
                 (prog1 . 1)
                 (prog2 . 2)
                 (progn . 0)
                 (progv . 2)
                 (return . 0)
                 (return-from . 1)
                 (symbol-macrolet . let)
                 (tagbody . 0)
                 (throw . 1)
                 (unless . 1)
                 (unwind-protect . 0)
                 (when . 1)
                 (with-accessors . multiple-value-bind)
                 (with-condition-restarts . multiple-value-bind)
                 (with-output-to-string . 1)
                 (with-slots . multiple-value-bind)
                 (with-standard-io-syntax . 2)))
    (setf (get (car elt) 'lisp-indent) (cdr elt))))

(defvar *lisp-mode-keymap*
  (make-keymap "lisp" 'undefined-key *global-keymap*))

(define-mode lisp-mode
  :name "lisp-mode"
  :keymap *lisp-mode-keymap*
  :syntax-table (make-syntax-table
                 :space-chars '(#\space #\tab #\newline)
                 :symbol-chars '(#\$ #\& #\* #\+ #\- #\_ #\< #\> #\= #\/ #\:)
                 :paren-alist '((#\( . #\))
                                (#\[ . #\])
                                (#\{ . #\}))
                 :string-quote-chars '(#\")
                 :escape-chars '(#\\)
                 :expr-prefix-chars '(#\' #\, #\@ #\# #\`)
                 :line-comment-char #\;))

(defun lisp-looking-at-word ()
  (let ((point (point)))
    (skip-chars-forward
     (lambda (c)
       (or (eq c #\space)
           (eq c #\tab))))
    (let ((begin (point)))
      (forward-sexp)
      (prog1 (list (region-string begin (point))
                   (when (= (window-cur-linum)
                            (progn
                              (skip-chars-forward 'syntax-space-char-p)
                              (window-cur-linum)))
                     (window-cur-col)))
             (point-set point)))))

(defun lisp-count-sexps (goal)
  (do ((count 0 (1+ count)))
      (nil)
    (unless (forward-sexp)
      (return (values count nil)))
    (when (point< goal (point))
      (return (values count t)))))

(define-key *lisp-mode-keymap* "C-i" 'lisp-indent-line)
(define-command lisp-indent-line () ()
  (beginning-of-line)
  (let ((point (point))
        (blank-line-flag (blank-line-p)))
    (when (and (up-list 1) (down-list 1))
      (let ((start-col (1- (window-cur-col))))
        (destructuring-bind (car-name-str arg-col)
            (lisp-looking-at-word)
          (let* ((car-name (intern (string-upcase car-name-str) :lem))
                 (count (lisp-count-sexps point)))
            (when blank-line-flag
              (incf count))
            (let ((num
                   (do ((val (get car-name 'lisp-indent))
                        (count 0 (1+ count)))
                       ((numberp val) val)
                     (when (< 10 count) (return))
                     (setq val (get val 'lisp-indent)))))
              (point-set point)
              (delete-while-whitespaces t)
              (cond
               ((and (null num)
                     (or (eql 0 (search "define-" car-name-str))
                         (eql 0 (search "with-" car-name-str))
                         (eql 0 (search "do-" car-name-str))))
                (insert-char #\space (+ start-col 2)))
               ((null num)
                (if arg-col
                  (insert-char #\space arg-col)
                  (insert-char #\space (+ start-col 1))))
               ((< (1- count) num)
                (insert-char #\space (+ start-col 4)))
               (t
                (insert-char #\space (+ start-col 2)))))))))))

(define-key *lisp-mode-keymap* "C-j" 'newline-and-indent)
(define-command newline-and-indent (n) ("p")
  (insert-newline n)
  (lisp-indent-line))

(defun string-to-exps (str)
  (let ((str str)
        (exps)
        (eof-value (make-symbol "eof")))
    (do ()
        ((string= "" str))
      (multiple-value-bind (expr i)
          (read-from-string str nil eof-value)
        (when (eq expr eof-value)
          (return))
        (push expr exps)
        (setq str (subseq str i))))
    (cons 'progn (nreverse exps))))

(define-command eval-region (&optional begin end) ("r")
  (unless (or begin end)
    (setq begin (region-beginning))
    (setq end (region-end)))
  (let ((expr (string-to-exps (region-string begin end))))
    (write-message (format nil "~a" (eval expr))))
  t)

(define-key *lisp-mode-keymap* "M-C-x" 'eval-defun)
(define-command eval-defun () ()
  (let ((point (point)))
    (top-of-defun)
    (mark-sexp)
    (eval-region)
    (point-set point)
    t))

(define-key *lisp-mode-keymap* "C-xu" 'eval-last-sexp)
(define-command eval-last-sexp () ()
  (let ((point (point)))
    (when (backward-sexp)
      (mark-sexp)
      (eval-region)
      (point-set point)
      t)))

(define-key *lisp-mode-keymap* "C-xy" 'eval-buffer)
(define-command eval-buffer () ()
  (let ((point (point)))
    (eval-region (progn (beginning-of-buffer) (point))
                 (progn (end-of-buffer) (point)))
    (point-set point)
    t))

(define-key *lisp-mode-keymap* "C-xl" 'load-file)
(define-command load-file (filename) ("fLoad File: ")
  (write-message
   (format nil "~a"
           (load filename))))

(define-key *lisp-mode-keymap* "C-xz" 'go-to-lisp)
(define-key *lisp-mode-keymap* "M-z" 'go-to-lisp)
(define-command go-to-lisp () ()
  (save-some-buffers)
  (dolist (buffer *buffer-list*)
    (when (eq 'lisp-mode (buffer-major-mode buffer))
      (if (buffer-filename buffer)
        (load (buffer-filename buffer))
        (progn
          (set-buffer buffer)
          (eval-buffer)
          (unmark-buffer)))))
  (exit-lem))

(define-key *lisp-mode-keymap* "C-xm" 'macroexpand-lisp)
(define-command macroexpand-lisp (arg) ("P")
  (let ((expr
         (read-from-string
          (region-string (point)
                         (let ((start (point)))
                           (forward-sexp)
                           (prog1 (point)
                             (point-set start))))))
        (*current-window*
         (pop-to-buffer
          (get-buffer-create "*macroexpand*"))))
    (erase-buffer)
    (beginning-of-buffer)
    (insert-string
     (with-output-to-string (s)
       (pprint (if arg
                 (macroexpand expr)
                 (macroexpand-1 expr))
               s)))
    (beginning-of-buffer)))
