(in-package :lem)

(defun char-before-2 ()
  (char-before 2))

(defun char-before-3 ()
  (char-before 3))

(defmacro flet-aliases (aliases &body body)
  (let ((gargs (gensym "args")))
    `(flet ,(mapcar (lambda (alias)
                      (assert (= 2 (length alias)))
                      `(,(car alias) (&rest ,gargs)
                         (apply #',(cadr alias) ,gargs)))
              aliases)
       ,@body)))

(defmacro define-dir-functions ((forward-name backward-name) parms aliases &body body)
  `(progn
    (flet ((forward-p () t)
           (backward-p () nil))
      (defun ,forward-name ,parms ,@body))
    (flet ((forward-p () nil)
           (backward-p () t))
      (flet-aliases ,aliases
        (defun ,backward-name ,parms ,@body)))))

(define-dir-functions (skip-chars-forward skip-chars-backward)
  (pred &optional not-p)
  ((following-char preceding-char)
   (next-char prev-char))
  (do ()
      ((if (funcall pred (following-char))
         not-p
         (not not-p))
       t)
    (unless (next-char 1)
      (return))))

(defun skip-space-forward ()
  (skip-chars-forward 'syntax-space-char-p))

(defun skip-space-backward ()
  (skip-chars-backward 'syntax-space-char-p))

(defun skip-until-open-paren-forward ()
  (skip-chars-forward 'syntax-open-paren-char-p t))

(defun skip-until-closed-paren-backward ()
  (skip-chars-backward 'syntax-closed-paren-char-p t))

(defun escape-p (before-1 before-2)
  (and (syntax-escape-char-p before-1)
       (not (syntax-escape-char-p before-2))))

(defun escape-forward-p ()
  (escape-p (preceding-char) (char-before-2)))

(defun escape-backward-p ()
  (escape-p (char-before-2) (char-before-3)))

(define-dir-functions (forward-list-1 backward-list-1) ()
  ((skip-until-open-paren-forward skip-until-closed-paren-backward)
   (following-char preceding-char)
   (syntax-pair-closed-paren syntax-pair-open-paren)
   (preceding-char char-before-2)
   (char-before-2 char-before-3)
   (forward-list-1 backward-list-1)
   (prev-char next-char)
   (next-char prev-char)
   (skip-string-forward skip-string-backward)
   (escape-forward-p escape-backward-p))
  (skip-until-open-paren-forward)
  (let* ((paren-char (following-char))
         (goal-char (syntax-pair-closed-paren paren-char))
         (point (point)))
    (do () (nil)
        (unless (next-char 1)
          (point-set point)
          (return))
      (unless (escape-forward-p)
        (let ((c (following-char)))
          (cond
           ((eql c paren-char)
            (forward-list-1)
            (prev-char 1))
           ((eql c goal-char)
            (next-char 1)
            (do ()
                ((not (and (backward-p)
                           (syntax-expr-prefix-char-p
                            (following-char)))))
              (next-char 1))
            (return t))
           ((syntax-string-quote-char-p c)
            (skip-string-forward)
            (prev-char 1))))))))

(define-key *global-keymap* "M-C-n" 'forward-list)
(defcommand forward-list (n) ("p")
  (dotimes (_ n t)
    (unless (forward-list-1)
      (return))))

(define-key *global-keymap* "M-C-p" 'backward-list)
(defcommand backward-list (n) ("p")
  (dotimes (_ n t)
    (unless (backward-list-1)
      (return))))

(define-dir-functions (skip-string-forward skip-string-backward) ()
  ((skip-chars-forward skip-chars-backward)
   (following-char preceding-char)
   (next-char prev-char)
   (preceding-char char-before-2)
   (char-before-2 char-before-3)
   (escape-forward-p escape-backward-p))
  (skip-chars-forward 'syntax-string-quote-char-p t)
  (let ((goal-char (following-char)))
    (do () (nil)
      (unless (next-char 1)
        (return))
      (unless (escape-forward-p)
        (when (eql (following-char) goal-char)
          (next-char 1)
          (return t))))))

(define-dir-functions (skip-symbol-forward skip-symbol-backward) ()
  ((next-char prev-char)
   (following-char preceding-char)
   (preceding-char char-before-2)
   (char-before-2 char-before-3)
   (escape-forward-p escape-backward-p))
  (do () (nil)
    (unless (next-char 1)
      (return))
    (let ((c (following-char)))
      (cond
       ((escape-forward-p))
       ((not
         (or
          (syntax-escape-char-p c)
          (syntax-symbol-char-p c)
          (syntax-word-char-p c)))
        (return t))))))

(defun start-sexp-p (c)
  (or (syntax-open-paren-char-p c)
      (and (syntax-expr-prefix-char-p c)
           (syntax-open-paren-char-p (char-after 1)))
      (and (syntax-expr-prefix-char-p c)
           (syntax-expr-prefix-char-p (char-after 1))
           (syntax-open-paren-char-p (char-after 2)))))

(define-dir-functions (%forward-sexp %backward-sexp) ()
  ((skip-space-forward skip-space-backward)
   (start-sexp-p syntax-closed-paren-char-p)
   (syntax-closed-paren-char-p syntax-open-paren-char-p)
   (following-char preceding-char)
   (preceding-char char-before-2)
   (char-before-2 char-before-3)
   (forward-list-1 backward-list-1)
   (skip-string-forward skip-string-backward)
   (skip-symbol-forward skip-symbol-backward)
   (next-char prev-char)
   (escape-forward-p escape-backward-p))
  (skip-space-forward)
  (let ((c (following-char)))
    (when (escape-forward-p)
      (next-char 1)
      (setq c (following-char)))
    (cond
     ((start-sexp-p c)
      (forward-list-1))
     ((syntax-closed-paren-char-p c)
      nil)
     ((syntax-string-quote-char-p c)
      (skip-string-forward))
     (t
      (skip-symbol-forward)))))

(define-key *global-keymap* "M-C-f" 'forward-sexp)
(defcommand forward-sexp (n) ("p")
  (dotimes (_ n t)
    (unless (%forward-sexp)
      (return))))

(define-key *global-keymap* "M-C-b" 'backward-sexp)
(defcommand backward-sexp (n) ("p")
  (dotimes (_ n t)
    (unless (%backward-sexp)
      (return))))

(define-key *global-keymap* "M-C-d" 'down-list)
(defcommand down-list (n) ("p")
  (block outer
    (dotimes (_ n t)
      (let ((point (point)))
        (do ()
            ((and
              (syntax-open-paren-char-p (following-char))
              (not (escape-forward-p)))
             (next-char 1))
          (when (or
                 (syntax-closed-paren-char-p (following-char))
                 (not (next-char 1)))
            (point-set point)
            (return-from outer nil)))))))
