(in-package :lem)

(defun skip-chars-forward (pred &optional not-p)
  (do ()
      ((if (funcall pred (following-char))
         not-p
         (not not-p))
       t)
    (unless (next-char 1)
      (return))))

(defun skip-chars-backward (pred &optional not-p)
  (do ()
      ((if (funcall pred (preceding-char))
         not-p
         (not not-p))
       t)
    (unless (prev-char 1)
      (return))))

(defun skip-space-forward ()
  (skip-chars-forward 'syntax-space-char-p))

(defun skip-space-backward ()
  (skip-chars-backward 'syntax-space-char-p))

(defun two-preceding-char ()
  (when (prev-char 1)
    (prog1 (preceding-char)
      (next-char 1))))

(defun forward-list ()
  (skip-chars-forward 'syntax-open-paren-char-p t)
  (let* ((paren-char (following-char))
         (goal-char (syntax-pair-closed-paren paren-char)))
    (do () (nil)
      (unless (next-char 1)
        (return))
      (unless (syntax-escape-char-p (preceding-char))
        (let ((c (following-char)))
          (cond
           ((char= c paren-char)
            (forward-list)
            (prev-char 1))
           ((char= c goal-char)
            (next-char 1)
            (return t))
           ((syntax-string-quote-char-p c)
            (skip-string-forward)
            (prev-char 1))))))))

(defun backward-list ()
  (skip-chars-backward 'syntax-closed-paren-char-p t)
  (let* ((paren-char (preceding-char))
         (goal-char (syntax-pair-open-paren paren-char)))
    (do () (nil)
      (unless (prev-char 1)
        (return))
      (unless (syntax-escape-char-p (two-preceding-char))
        (let ((c (preceding-char)))
          (cond
           ((char= c paren-char)
            (backward-list)
            (next-char 1))
           ((char= c goal-char)
            (prev-char 1)
            (return t))
           ((syntax-string-quote-char-p c)
            (skip-string-backward)
            (next-char 1))))))))

(defun skip-string-forward ()
  (skip-chars-forward 'syntax-string-quote-char-p t)
  (let ((goal-char (following-char)))
    (do () (nil)
      (unless (next-char 1)
        (return))
      (when (and
             (not (syntax-escape-char-p (preceding-char)))
             (char= (following-char) goal-char))
        (next-char 1)
        (return t)))))

(defun skip-string-backward ()
  (skip-chars-backward 'syntax-string-quote-char-p t)
  (let ((goal-char (preceding-char)))
    (do () (nil)
      (unless (prev-char 1)
        (return))
      (when (and
             (not (syntax-escape-char-p (two-preceding-char)))
             (char= (preceding-char) goal-char))
        (prev-char 1)
        (return t)))))

(defun skip-symbol-forward ()
  (do () (nil)
    (unless (next-char 1)
      (return))
    (let ((c (following-char)))
      (unless (or (syntax-symbol-char-p c)
                  (syntax-word-char-p c))
        (return t)))))

(defun skip-symbol-backward ()
  (do () (nil)
    (unless (prev-char 1)
      (return))
    (let ((c (preceding-char)))
      (unless (or (syntax-symbol-char-p c)
                  (syntax-word-char-p c))
        (return t)))))

(define-key *global-keymap* "M-C-f" 'forward-sexp)
(defcommand forward-sexp (n) ("p")
  (dotimes (_ n t)
    (skip-space-forward)
    (let ((c (following-char)))
      (cond
       ((syntax-open-paren-char-p c)
        (forward-list))
       ((syntax-closed-paren-char-p c)
        (return nil))
       ((syntax-string-quote-char-p c)
        (skip-string-forward))
       (t
        (skip-symbol-forward))))))

(define-key *global-keymap* "M-C-b" 'backward-sexp)
(defcommand backward-sexp (n) ("p")
  (dotimes (_ n t)
    (skip-space-backward)
    (let ((c (preceding-char)))
      (cond
       ((syntax-closed-paren-char-p c)
        (backward-list))
       ((syntax-open-paren-char-p c)
        (return nil))
       ((syntax-string-quote-char-p c)
        (skip-string-backward))
       (t
        (skip-symbol-backward))))))
