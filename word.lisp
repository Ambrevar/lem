(in-package :lem)

(defun in-word-p (c)
  (when c
    (or (char<= #\a c #\z)
        (char<= #\A c #\Z)
        (char<= #\0 c #\9))))

(defun next-word-aux (fn)
  (do () ((in-word-p (following-char)))
    (unless (funcall fn)
      (return)))
  (do () ((not (in-word-p (following-char))))
    (unless (funcall fn)
      (return))))

(defun prev-word-aux (fn)
  (do () ((in-word-p (preceding-char)))
    (unless (funcall fn)
      (return)))
  (do () ((not (in-word-p (preceding-char))))
    (unless (funcall fn)
      (return))))

(define-key *global-keymap* "M-f" 'next-word)
(defcommand next-word (n) ("p")
  (if (minusp n)
    (prev-word (- n))
    (dotimes (_ n t)
      (unless (next-word-aux 'next-char)
        (return)))))

(define-key *global-keymap* "M-b" 'prev-word)
(defcommand prev-word (n) ("p")
  (if (minusp n)
    (next-word (- n))
    (dotimes (_ n t)
      (unless (prev-word-aux 'prev-char)
        (return)))))

(define-key *global-keymap* "M-d" 'delete-word)
(defcommand delete-word (n) ("p")
  (if (minusp n)
    (backward-delete-word (- n))
    (dotimes (_ n t)
      (unless (next-word-aux (lambda () (delete-char 1)))
        (return)))))

(define-key *global-keymap* "M-C-h" 'backward-delete-word)
(defcommand backward-delete-word (n) ("p")
  (if (minusp n)
    (delete-word (- n))
    (let ((*kill-before-p* t))
      (dotimes (_ n t)
        (unless (prev-word-aux (lambda () (backward-delete-char 1)))
          (return))))))
